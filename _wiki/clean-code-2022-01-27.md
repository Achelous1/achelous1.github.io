---
layout  : wiki
title   : 클린코드 2022-01-27의 기록
summary : 
date    : 2022-01-27 22:52:19 +0900
updated : 2022-01-27 22:52:19 +0900
tag     : clean-code nomad-coders
toc     : true
public  : true
parent  : [[nomad-book-club]]
latex   : false
---
* TOC
{:toc}

# DAY
* 오늘 읽은 범위 : 함수 ~65

### 책에서 기억하고 싶은 내용을 써보세요
> [2022-01-27로부터 계속](https://achelous1.github.io/wiki/clean-code-2022-01-26/#%EC%B1%85%EC%97%90%EC%84%9C-%EA%B8%B0%EC%96%B5%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%80-%EB%82%B4%EC%9A%A9%EC%9D%84-%EC%8D%A8%EB%B3%B4%EC%84%B8%EC%9A%94)
> * 함수에서 가장 이상적인 인수의 갯수는 **0개** 그리고 그다음은 1개, 2개이다. 3개는 가능한 피하는편이 좋고 4개의 인수는 사용할 특별한 이유가 없다 -인수는 함수의 개념을 어렵게 만든다
>     * 인수는 코드를 읽는 사람으로 하여금 그 인수의 의미를 계속해서 해석해야하는 번거로움을 발생시킨다.
>     * 코드를 해석하는 사람으로써는 인수가 없는편이 있는편보다 훨씬 해석하기가 편하다.
>     * 해당 시점에 중요하지 않은 세부사항(인수)를 이해해야 한다.
> * **함수에 인수를 1개를 넘기는 이유:**
>      1. 인수에 질문을 던지는 경우다
>      ```java
>      boolean fileExists("MyFile")		// String형식으로 받은 파일이름이 존재하는지 확인하는 함수다
>      ```
>      2. 인수를 뭔가로 변환해 결과를 반환하는 경우다
>      ```java
>      InputStream fileOpen("MyFile")	// String형식의 파일이름을 InputStream으로 리턴받는다
>      ```
>      3. 이벤트-드물게 사용하지만 아주 유용한 함수형식이다
>          * 입력인수만 있으며 출력인수는 없다.
>          * 이벤트 함수는 해당 함수가 이벤트라는 사실이 코드에 명확히 드러나야 한다
>      ```java
>      passwordAttemptFailedNtimes(int attempts)	// 비밀번호를 몇번 틀렸는지 알려주는 함수다
>      ```
> * **플래그인수**는 사용하지 않는다. 함수에 부울값을 넘기는 관례는 끔찍하다고 설명한다!-이는 함수가 여러가지를 처리한다고 대놓고 공표하는셈-
>     * 플래그를 넘기기보다 각각의 행위를 처리하는 함수를 따로 만들어야 함이 마땅하다.
> * **인수가 두개인 함수는 한개인 함수보다 이해하기 어렵다!**
>     * 인수가 두개인 경우는 하나의 인수를 무시하는 경향이 발생한다. 이는 결국 문제를 일으킨다! - 어떤 코드든 절대로 무시하면 안되니까. **무시한 코드에 오류가 숨어드니까**
>     * 2개의 인수가 적절한 예:
>     ```java
>     Point p = new Point(0, 0) 	// 2차원의 한 점을 나타낼때
>     ```
>     * 테스트코드 작성 시에도 많은 실수가 발생한다.
>     ```java
>     assertEquals(expected, actual)	// expected 인수에 actual을 집어넣는 실수를 반복하기도 한다
>     ```
> * **삼항함수를 만들때에는 신중을 고려하라**
>     * 순서, 주춤, 무시로 야기되는 문제가 두배이상 발생한다!
> 많은 인수가 필요한 함수를 정의해야 한다면 **독자적인 클래스 변수로 선언할 가능성을 짚어보라**
> * 인수의 갯수가 가변적인 함수의 경우엔 가변적인 리스트 -`args`와 같은-를 하나의 인수로 본다
> * 함수의 의도를 명확하게 표현하기 위해선 동사/명사를 함께 쓰라 `write(name)`보다 `writeField(name)`이 훨씬 명확한 것 처럼.
> * 함수에서 하기로 했던 행위 이외의 행위-부수효과-를 일으키지마라![^LIST36-1]
>     * 함수명에서 드러나지 않는 행위를 하는 위험에 처한다
>     * 시간적인 결합 즉, 특정상황에서만 해당 함수를 호출할 수 있게 된다
> * 오류코드를 반환하기보다는 **예외**를 사용해라!-오류코드를 함수에서 반환하면 여러단계로 중첩되는 코드를 야기할 수 있다
>     * 예외를 사용하면 오류처리코드가 원래코드에서 분리되므로 코드가 깔끔해지게 된다!(try-catch를 깔끔하게 쓰려면 58페이지의 **Try/Catch 블록 뽑아내기** 소제목을 참조)
> * **중복은 소프트웨어에서 모든 악의 근원이다!**
> * *모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다* - 데이크스트라[^DIJKSTRA-2]
>     * 루프 안에서 continue나 break는 절대 안된다!
> * *처음부터 함수를 앞에서 말한 것 처럼 짤 수는 없다. 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수가 많은건 말할 필요도 없다. 이름은 즉흥적이고 코드는 중복된다. 하지만 **코드를 빠짐없이 테스트하는 단위테스트 케이스를 만든다**. 그 다음 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 전체 클래스를 쪼개기도 한다. **하지만 코드는 모든 단위테스트를 통과한다.***
>     * 단위테스트의 중요성!
### 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요
> 1. 오늘은 뭔가 함수에 대한 많은 내용이 나온것 같습니다. 코드도 많이 나오고 함수에 대한 클린코드의 철학이 여실히 묻어나오는 내용들이 많아 소화하는데 시간이 좀 걸린 것 같습니다. 하지만 목록 3-7에서 나온 코드를 보고, 내가 봐왔던 코드들은 모두 이런식으로 짜여져 왔구나라는 것을 새삼 느끼게 되었습니다. 개발자로써 현재의 내 코드에 안주하지 않고 한발자국 더 나아가는 사람이 되어야겠다 느낀 시간이었습니다.
### 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요
> * 출력인수란 무엇인가? 해당 내용은 51페이지 **많이 쓰는 단항형식** 소주제의 3번째문단에 나와있다. `void includeSetupPageInto(StringBuffer pageText)`라는 함수에서는 `pageText`라는 인수를 reference하기위해 넘겨주고 아무것도 리턴받지 않았다. 이는 `pageText`라는 상위 추상화 개념을 더 낮은 추상화 개념의 함수에 넘겨준 것이다. 이는 코드를 해석하는 사람으로 하여금 `pageText`라는 인수의 개념을 매번 이해하고 넘어가도록 만들어버린다.
> * 구조적 프로그래밍이란?[^SP-3]
### 세줄 요약
> * 인수는 적을수록 좋다! 최고는 0개!
> * 함수에서 하기로 했던 행위 이외의 행위는 하지마라!
> * 이 장에서 설명한 규칙의 함수를 만들어나가라! 어떻게? 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 클래스를 쪼개기도 한다!
## Links
* [노개북 README](https://nomadcoders.oopy.io/readme?utm_source=Nomad_Book_Club%231&utm_campaign=853979327e-EMAIL_CAMPAIGN_2022_01_20_09_04&utm_medium=email&utm_term=0_26f5b50d66-853979327e-357549064)
* [TIL 출석표](https://docs.google.com/spreadsheets/d/1Cy2NOnfFDP6Y1snkd3nL5VidLDmBq8C9696iTwbc_K0/edit#gid=0)

## 주석
[^LIST36-1]: p55 목록 3-6참조
[^DIJKSTRA-2]: 에츠허르 데히크스트라 - 네덜란드의 전산학자 [위키피디아](https://ko.wikipedia.org/wiki/%EC%97%90%EC%B8%A0%ED%97%88%EB%A5%B4_%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC)
[^SP-3]: 구조적 프로그래밍 [위키피디아](https://ko.wikipedia.org/wiki/%EA%B5%AC%EC%A1%B0%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D#:~:text=%EA%B5%AC%EC%A1%B0%EC%A0%81%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D(structured%20programming)%EC%9D%80,%EC%A3%BC%EB%8A%94%20%EA%B2%83%EC%9C%BC%EB%A1%9C%20%EA%B0%80%EC%9E%A5%20%EC%9C%A0%EB%AA%85%ED%95%98%EB%8B%A4.)
